# ReUntangle - システムアーキテクチャ

## 概要
ReUntangleは、完全にクライアントサイドで動作するWebアプリケーションです。すべての処理はブラウザ内で完結し、ユーザーのファイルデータは外部に送信されません。

---

## アーキテクチャ概要図

```
┌─────────────────────────────────────────────────────────┐
│                      Browser (Client)                    │
│                                                           │
│  ┌─────────────────────────────────────────────────┐   │
│  │              Presentation Layer                  │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐     │   │
│  │  │  Next.js  │  │ @xyflow/ │  │ Tailwind │     │   │
│  │  │  Pages    │  │  react   │  │   CSS    │     │   │
│  │  └──────────┘  └──────────┘  └──────────┘     │   │
│  └─────────────────────────────────────────────────┘   │
│                          ↓                               │
│  ┌─────────────────────────────────────────────────┐   │
│  │              Application Layer                   │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐     │   │
│  │  │  Custom   │  │  State   │  │ Business │     │   │
│  │  │  Hooks    │  │ Management│ │  Logic   │     │   │
│  │  └──────────┘  └──────────┘  └──────────┘     │   │
│  └─────────────────────────────────────────────────┘   │
│                          ↓                               │
│  ┌─────────────────────────────────────────────────┐   │
│  │               Service Layer                      │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐     │   │
│  │  │  Parser   │  │  Graph   │  │ Analysis │     │   │
│  │  │  Engine   │  │ Builder  │  │  Engine  │     │   │
│  │  └──────────┘  └──────────┘  └──────────┘     │   │
│  └─────────────────────────────────────────────────┘   │
│                          ↓                               │
│  ┌─────────────────────────────────────────────────┐   │
│  │              Data Access Layer                   │   │
│  │  ┌──────────┐  ┌──────────┐                    │   │
│  │  │File System│ │ Browser  │                    │   │
│  │  │Access API │  │ Storage  │                    │   │
│  │  └──────────┘  └──────────┘                    │   │
│  └─────────────────────────────────────────────────┘   │
│                                                           │
└─────────────────────────────────────────────────────────┘
                          ↓
              ┌──────────────────────┐
              │   Local File System  │
              └──────────────────────┘
```

---

## レイヤー構成

### 1. Presentation Layer（プレゼンテーション層）

#### 責務
- ユーザーインターフェースの表示
- ユーザー操作の受付
- データの視覚的表現

#### 主要コンポーネント
- **Next.js Pages**: ルーティングとページ管理
- **React Components**: UI部品
- **@xyflow/react**: グラフ可視化
- **Tailwind CSS**: スタイリング

#### 技術
- Next.js 15.5+ (App Router)
- React 19.1+
- @xyflow/react 12.8+
- Tailwind CSS 3.4+

---

### 2. Application Layer（アプリケーション層）

#### 責務
- アプリケーション状態の管理
- ビジネスロジックの調整
- 各レイヤー間の橋渡し

#### 主要要素
- **Custom Hooks**: 再利用可能なロジック
  - `useAppState`: アプリケーション全体の状態管理
    - グラフデータ、レイアウトタイプ、選択中のコンポーネント
    - メトリクス、検索/フィルタオプション
  - `useProjectAnalysis`: プロジェクト解析の実行
    - ディレクトリスキャン、パース、グラフ構築の統合
    - 解析進行状態の管理
  - `useGraphLayout`: グラフレイアウト計算
    - Hierarchical / Force-directed レイアウトの適用
    - React Flowノード位置の更新
  - `useGraphFilter`: グラフフィルタリング
    - 検索クエリ、複雑度範囲、タイプ別フィルタ
    - フィルタ適用後のノード・エッジ生成
  - `useNodeClickHandler`: ノードクリックイベント処理
    - 選択コンポーネントの詳細表示
- **State Management**: アプリケーション状態
  - ローカルステート（useState）- Context APIは不使用
- **Business Logic**: ビジネスルール
  - バリデーション
  - データ変換
  - エラーハンドリング

---

### 3. Service Layer（サービス層）

#### 責務
- コア機能の提供
- データ処理と解析
- グラフデータの生成

#### Parser Engine（解析エンジン）

**機能**:
- ファイルスキャン
- AST（抽象構文木）解析
- 依存関係抽出

**使用ライブラリ**:
- `@babel/parser`: コードのパース
- `@babel/traverse`: AST走査

**処理フロー**:
```
1. AST生成 (@babel/parser)
    ↓
2. import文解析
    ↓
3. コンポーネント特定
    ↓
4. 各コンポーネントごとに以下を抽出:
   ├─ React Hooks検出・カウント
   ├─ カスタムHook呼び出し検出
   ├─ TypeScript Props型情報抽出
   ├─ コード行数計算
   ├─ 外部ライブラリ数カウント
   ├─ 依存関係抽出 (import + カスタムHook)
   └─ 複雑度計算
```

**抽出される情報**:
- コンポーネント名
- ファイルパス
- コンポーネントタイプ (function, class, arrow, hook)
- import文リスト（内部/外部の区別あり）
- 依存関係（import文 + カスタムHook呼び出し）
- コード行数
- TypeScript Props型定義 (interface/type)
- React Hooks使用状況 (useState, useEffect等)
- カスタムHook呼び出し一覧
- 外部ライブラリ使用数
- 複雑度スコア (0-100)

#### Graph Builder（グラフ構築）

**機能**:
- ノード/エッジデータの生成
- レイアウト計算
- グラフ最適化
- ノードの視覚的強調表示

**ノードの視覚的表現**:
- **色分け（優先順位順）**:
  - 赤 (Red): 循環依存あり
  - 紫 (Purple): ルートコンポーネント（page.tsx, layout.tsx等）
  - グレー (Gray): 未使用コンポーネント
  - 緑 (Green): 複雑度 ≤ 30（シンプル）
  - 青 (Blue): 複雑度 31-60（標準）
  - 黄 (Yellow): 複雑度 61-80（複雑）
  - オレンジ (Orange): 複雑度 > 80（非常に複雑）

- **サイズ調整**:
  - 基本サイズ: 複雑度に応じて 40px〜100px
  - 高結合度警告がある場合: サイズを1.3倍に拡大

- **ボーダースタイル**:
  - 循環依存: 赤3px太枠
  - 深い依存チェーン: 黄3px太枠 + シャドウ
  - 高結合度: オレンジ3px太枠 + シャドウ

**処理フロー**:
```
1. buildGraph(): 基本グラフ構築
   ├─ ノード生成（基本情報のみ）
   ├─ エッジ生成
   ├─ 深さ計算（トポロジカルソート）
   └─ 警告検出（深い依存/高結合/未使用）

2. buildReactFlowGraph(): ビジュアライゼーション
   ├─ 循環依存検出（DFS）
   ├─ ノードスタイル決定（色・サイズ・ボーダー）
   └─ React Flowフォーマット変換

3. レイアウト計算（別モジュール: useGraphLayout）
```

#### Analysis Engine（分析エンジン）

**機能**:
- 複雑度計算
- 警告検出システム
- メトリクス算出
- TypeScript型情報抽出
- React Hooks検出

**複雑度計算**:
各メトリクスを正規化（0-100）し、重み付け平均で算出:
```
複雑度スコア (0-100) =
  locScore     * 0.25  // コード行数 (200行で100)
+ depScore     * 0.20  // 依存関係数 (10個で100)
+ hooksScore   * 0.20  // Hooks使用数 (10個で100)
+ propsScore   * 0.15  // Props数 (15個で100)
+ libScore     * 0.05  // 外部ライブラリ数 (5個で100)
+ 追加スコア   * 0.15  // JSX複雑度、ネスト深さ等
```

**警告検出システム**:
実装されている警告タイプ:
1. **循環依存 (Circular Dependency)**
   - DFS（深さ優先探索）で循環を検出
   - パフォーマンス問題やバンドルサイズ肥大化のリスク

2. **未使用コンポーネント (Unused Component)**
   - dependents.length === 0 かつルートでない
   - デッドコードの可能性

3. **深い依存チェーン (Deep Dependency Chain)**
   - depth > 5（依存の深さが6階層以上）
   - メンテナンス性の低下リスク

4. **高結合度 (High Coupling)**
   - dependents.length >= 10（10個以上から参照されている）
   - 変更の影響範囲が大きくなるリスク

**TypeScript Props情報抽出**:
- TypeScript interfaceからProps定義を自動抽出
- 各Propの型、必須/任意、デフォルト値を解析
- DetailPanelで詳細表示

**React Hooks検出**:
- `useState`, `useEffect`, `useContext`などの標準Hooks自動検出
- カスタムHooks (`useXxxHook`パターン) の依存関係追跡
- 使用回数のカウント

**分析項目**:
- コンポーネント複雑度 (0-100スコア)
- 依存の深さ
- 警告・推奨事項 (4種類)
- Props情報 (TypeScript型定義)
- React Hooks使用状況

---

### 4. Data Access Layer（データアクセス層）

#### 責務
- ローカルファイルシステムへのアクセス
- ブラウザストレージの管理
- キャッシング

#### File System Access

**API**: File System Access API
**操作**:
- ディレクトリ選択
- ファイル読み込み
- 再帰的スキャン

**セキュリティ**:
- ユーザー明示的な許可が必要
- 読み取り専用
- データ非送信

#### Browser Storage

**使用技術**:
- LocalStorage: 設定の永続化
- SessionStorage: 一時データ

**保存データ**:
- レイアウト設定
- フィルタ設定
- 最後に開いたプロジェクトパス（パスのみ、内容は保存しない）

#### Cache Layer

> **注意**: キャッシュ機能は現在未実装です。将来の拡張予定機能として記載しています。

**キャッシュ対象（計画）**:
- 解析済みAST
- グラフデータ
- 計算済みメトリクス

**キャッシュ戦略（計画）**:
- メモリキャッシュ（セッション中のみ）
- ファイルハッシュベースの無効化

---

## データフロー

### 解析フロー

```
1. ユーザーがフォルダを選択
         ↓
2. File System Access APIでファイル一覧取得（再帰的スキャン）
         ↓
3. React/TSファイルをフィルタリング (.tsx, .ts, .jsx, .js)
         ↓
4. 各ファイルを解析（現在は直列処理）
   ├─ AST生成 (@babel/parser)
   ├─ import文抽出
   ├─ コンポーネント特定 (function/class/arrow/hook)
   ├─ React Hooks検出・カウント
   ├─ TypeScript Props型情報抽出
   ├─ カスタムHook呼び出し検出
   ├─ コード行数計算
   └─ 複雑度計算（重み付け平均）
         ↓
5. 依存関係グラフを構築 (GraphBuilder.buildGraph)
   ├─ ノード生成（基本情報のみ）
   ├─ エッジ生成（依存関係マッピング）
   ├─ 深さ計算（トポロジカルソート）
   └─ 警告検出（深い依存/高結合/未使用）
         ↓
6. React Flowフォーマットに変換 (GraphBuilder.buildReactFlowGraph)
   ├─ 循環依存検出（DFS）
   ├─ ノードスタイル決定（色・サイズ・ボーダー）
   └─ エッジスタイル決定
         ↓
7. メトリクス算出 (GraphBuilder.calculateMetrics)
   ├─ 複雑度分布
   ├─ 最も複雑なコンポーネントTop 10
   └─ 最も依存されているコンポーネントTop 10
         ↓
8. レイアウト計算 (useGraphLayout)
   ├─ Hierarchical または Force-directed
   └─ ノード位置の決定
         ↓
9. UI表示（GraphView, MetricsDashboard）
```

### インタラクションフロー

```
ユーザー操作（クリック、ズームなど）
         ↓
イベントハンドラー
         ↓
状態更新（React State）
         ↓
再レンダリング
         ↓
UI更新
```

---

## 技術スタック詳細

### フロントエンド

| 技術 | バージョン | 用途 |
|------|-----------|------|
| Next.js | 15.5.3 | フレームワーク（App Router） |
| React | 19.1.0 | UIライブラリ |
| TypeScript | 5.5+ | 型安全性 |
| Tailwind CSS | 3.4+ | スタイリング |

### グラフ可視化

| 技術 | バージョン | 用途 |
|------|-----------|------|
| @xyflow/react | 12.8.4 | グラフ描画・インタラクション |

### コード解析

| 技術 | バージョン | 用途 |
|------|-----------|------|
| @babel/parser | 7.25+ | コードパース（JSX/TSX対応） |
| @babel/traverse | 7.25+ | AST走査 |
| @babel/types | 7.25+ | AST型定義 |

### ユーティリティ

| 技術 | バージョン | 用途 |
|------|-----------|------|
| lodash | 4.17+ | ユーティリティ関数 |

### 開発・テスト

| 技術 | バージョン | 用途 |
|------|-----------|------|
| Vitest | 3.2.4 | テストランナー |
| @testing-library/react | 16.0+ | コンポーネントテスト |
| @vitest/coverage-v8 | 3.2.4 | カバレッジ計測 |
| ESLint | 9.35+ | リンター |
| Prettier | 3.3+ | フォーマッター |

---

## セキュリティアーキテクチャ

### データプライバシー

**原則**:
1. データは外部に送信しない
2. ファイル内容はメモリ上でのみ処理
3. 永続化するのは設定のみ（ファイル内容は保存しない）

**実装**:
- すべての処理がクライアントサイド
- サーバーサイドコンポーネントなし
- 外部APIコールなし

### ブラウザセキュリティ

**File System Access API**:
- ユーザーの明示的な許可が必要
- Origin単位でのアクセス制御
- 読み取り専用アクセス

**Content Security Policy**:
- 信頼できるソースのみ許可
- inline scriptの制限
- XSS対策

---

## パフォーマンス最適化

### 解析の最適化

**並列処理（計画中）**:
> 現在未実装。将来的にWeb Workersを使用した並列化を予定。
- Web Workersでファイル解析を並列化
- メインスレッドをブロックしない

**遅延ロード**:
- 必要なファイルのみ解析
- 大規模プロジェクトでは段階的に処理

**キャッシング（計画中）**:
> 現在未実装。将来的にメモリキャッシュ機能を追加予定。
- 解析結果をメモリキャッシュ
- ファイルハッシュで変更検出

### レンダリングの最適化

**仮想化**:
- 表示領域のノードのみレンダリング
- 大規模グラフでもスムーズ

**メモ化**:
- React.memo でコンポーネント最適化
- useMemo でコストの高い計算をキャッシュ

**デバウンス**:
- 検索・フィルタリング処理
- ズーム・パン操作

---

## スケーラビリティ

### プロジェクトサイズ対応

| プロジェクトサイズ | コンポーネント数 | 対応策 |
|------------------|----------------|--------|
| 小規模 | 〜50 | 標準処理 |
| 中規模 | 51〜200 | 並列処理 |
| 大規模 | 201〜500 | 並列処理 + 仮想化 |
| 超大規模 | 501〜 | 並列処理 + 仮想化 + フィルタリング推奨 |

### 将来の拡張性

**プラグインアーキテクチャ（将来）**:
- カスタム解析ルール
- カスタムレイアウトアルゴリズム
- カスタムメトリクス

**マルチフレームワーク対応（将来）**:
- Vue.js解析エンジン
- Angular解析エンジン
- プラガブルな設計

---

## エラーハンドリング

### エラー分類

**ユーザーエラー**:
- 不正なフォルダ選択
- 権限エラー
→ ユーザーフレンドリーなメッセージ表示

**パースエラー**:
- 構文エラーのあるファイル
- サポート外の構文
→ スキップして処理継続、ログ記録

**システムエラー**:
- メモリ不足
- ブラウザAPI非対応
→ エラー画面表示、リカバリー提案

### エラー境界

**React Error Boundary（計画中）**:
> 現在未実装。将来的にエラーバウンダリーを追加予定。
- コンポーネントレベルでのエラー捕捉
- グレースフルなフォールバック表示
- エラーログの記録

---

## 監視とログ

### ログレベル

- **ERROR**: 致命的エラー
- **WARN**: 警告（処理は継続）
- **INFO**: 情報（解析開始/終了など）
- **DEBUG**: デバッグ情報（開発時のみ）

### パフォーマンス計測（計画中）

> 現在未実装。将来的にパフォーマンス計測機能を追加予定。

- 解析時間
- レンダリング時間
- メモリ使用量
- ユーザー操作のレスポンス時間

---

## デプロイメント

### ビルド構成

**開発環境**:
```bash
npm run dev
```
- Hot Reload
- ソースマップ
- 詳細なエラー表示

**本番環境**:
```bash
npm run build
npm run start
```
- コード最小化
- 最適化
- 圧縮

### ホスティング

**推奨プラットフォーム**:
- Vercel（Next.js開発元）
- Netlify
- Cloudflare Pages

**要件**:
- 静的ホスティング対応
- HTTPSサポート
- CDN配信

---

## まとめ

ReUntangleは、完全にクライアントサイドで動作するシンプルかつ強力なアーキテクチャを採用しています。

**主要な設計原則**:
1. **プライバシー第一**: データを外部に送信しない
2. **レイヤー分離**: 明確な責任分担
3. **パフォーマンス重視**: 大規模プロジェクトにも対応
4. **拡張性**: 将来の機能追加を考慮

---

## 実装状況

### 実装済み機能

**コア機能**:
- ✅ ファイルシステムアクセス（File System Access API）
- ✅ TypeScript/JavaScript/React ファイル解析
- ✅ AST解析による依存関係抽出
- ✅ グラフ可視化（React Flow）
- ✅ 検索・フィルタリング機能
- ✅ メトリクスダッシュボード

**解析機能**:
- ✅ コンポーネント複雑度計算
- ✅ TypeScript Props型情報抽出
- ✅ React Hooks自動検出
- ✅ カスタムHook依存関係追跡
- ✅ 4種類の警告検出システム
  - 循環依存
  - 未使用コンポーネント
  - 深い依存チェーン
  - 高結合度

**視覚化機能**:
- ✅ 複雑度ベースのノード色分け
- ✅ 警告による動的なノードサイズ調整
- ✅ 詳細情報パネル
- ✅ インタラクティブなグラフ操作（ズーム、パン）
- ✅ 複数のレイアウトアルゴリズム (Hierarchical, Force-directed)

**UI/UX**:
- ✅ レスポンシブデザイン
- ✅ ダークモード非対応（ライトモードのみ）
- ✅ ブラウザサポート検出

### 計画中の機能

**パフォーマンス最適化**:
- ⏳ Web Workers による並列ファイル解析
- ⏳ メモリキャッシュ機能
- ⏳ ファイルハッシュベースのキャッシュ無効化
- ⏳ パフォーマンス計測機能

**エラーハンドリング**:
- ⏳ React Error Boundary

**拡張機能**:
- ⏳ プラグインアーキテクチャ
- ⏳ マルチフレームワーク対応 (Vue.js, Angular)
- ⏳ カスタムメトリクス定義
- ⏳ エクスポート機能（PNG, SVG, JSON）

### 技術的負債・改善項目

なし（現時点で特定された技術的負債はありません）

---

**作成日**: 2025年10月17日
**最終更新**: 2025年10月18日
**バージョン**: 1.1